## P-NP 문제
출처 : [https://namu.wiki/w/P-NP 문제?from=P-NP](https://namu.wiki/w/P-NP%20%EB%AC%B8%EC%A0%9C?from=P-NP)

> 결정 문제
- 답이 Yes 아니면 No로 반호나되는 문제
- 예를 들어, 'a는 b의 배수인가?'
> 

### P 문제

- 결정 문제들 중에서 쉽게 풀리는 것을 모아 놓은 집합
- 어떤 결정 문제를 다항식 시간 이내에 그 문제의 답을 Yes와 No 중의 하나로 계산할 수 있는 알고리즘이 존재하다면, 그 문제는 P 문제이다
- a는 b의 배수인가 - 유클리드 호제법

### NP 문제

- 결정 문제 중에서 적어도 검산은 쉽게 할 수 있는 것을 모아 놓은 집합
- 어떤 결정 문제의 답이 Yes일 때, 그 문제의 답이 Yes라는 것을 입증하는 힌트가 주어지면, 그 힌트를 사용해서 그 문제의 답이 정말로 Yes라는 것을 다항식 시간 이내에 확인할 수 있는 문제
- 정수 n개로 이루어진 집합이 주어졌다고 할 떄, '이 집합의 부분집합들 중에서 원소의 합이 0이 되는 집합이 존재하는가?'

### 활용

- 소인수 분해 문제를 이용한 공개키 암호화 기법에 널리 사용되는 암호 알고리즘 기법 - RSA
- 큰 두 소수 p와 q, p*q = n
- n을 공개키로 하고 p와 q를 이용해서 개인키를 생성

## 정렬 알고리즘

### 선택 정렬 (Selection Sort)

- 해당 순서에 원소를 넣을 위치는 이미 정해져 있고, 어떤 원소를 넣을지 선택하는 알고리즘
- 기준 이후의 배열에서 최소값을 찾아 기준의 값과 교체
- 시간 복잡도 : 최선, 최악, 평균 모두 O(N^2) / n(n-1)/2
- 불안정 정렬
- 특징: 비교는 여러번 수행되지만, 실제 교환 횟수는 적기 때문에 많은 교환이 일어나야 하는 자료 상태에서 비교적 효율적인 면이 있다

### 거품 정렬 (Bubble Sort)

- 인접한 2개의 원소를 비교해 크기가 순서대로 되어 있지 않으면 서로 교환
- 첫번째 원소부터 시작하여 마지막 -1 번째 원소까지 비교, 맨 끝에 정렬된 원소들은 제외하고 반복
- 시간 복잡도 : 최선, 최악, 평균 모두 O(N^2) / n(n-1)/2
- 안정 정렬
- 특징: 교환 횟수가 많다
- 개선: 특정 단계에서 작업을 진행했는데 두 항목의 값을 교환한 작업이 한번도 이루어지지 않았다면 정렬이 완료되었다는 뜻이므로 종료

### 병합 정렬 (Merge Sort)

- 분할 정복 사용, 요소를 쪼갠 후 다시 합병시키면서 정렬해 나가는 방식
- 왼쪽 부분 배열과 오른쪽 부분 배열을 비교하면서 작은 원소를 sorted 배열에 넣고 남은 배열을 뒤에 붙임
- 시간 복잡도 : 최선, 최악, 평균 모두 O(N logN)
- 안정 정렬
- 특징: 임시 배열 필요 (제자리 정렬 아님), 순차적인 비교로 정렬 → LinkedList 의 정렬에 효율적(퀵보다)

### 삽입 정렬 (Insertion Sort)

- 새로운 원소를 기존의 정렬된 카드 사이에 올바른 자리를 찾아 삽입
- 2번째 원소부터 시작하여 삽입할 위치를 지정한 후 원소(삽입 위치 이후~현재 위치)를 뒤로 옮기고 지정된 자리에 삽입
- 시간 복잡도 : 최선 - O(N), 최악, 평균 - O(N^2)
- 안정 정렬
- 특징: 대부분 정렬된 경우에 매우 효율적 (다른 정렬 알고리즘의 일부로 사용됨)

### 퀵 정렬 (Quick Sort)

- 분할 정복 사용, (병합과 달리) 비균등 분할, 추가공간 X, 배열 가운데서 하나의 원소를 피벗(pivot)으로
- 왼쪽에는 피벗 보다 작은, 오른쪽에는 피벗 보다 큰 원소들을 놓고 다시 퀵 정렬 (R 먼저 p 보다 작은 애 찾고 L 이 R 보다 작으면서 p 보다 같거나 큰 애를 찾으면서 전진하다가 같아지면 p 와 교체)
- 시간 복잡도 : 최선 - O(N logN), 최악 - O(N^2) (오름 차순 혹은 내림 차순으로 정렬된 경우)
- 불안정 정렬
- 특징: 정렬된 배열에서 불균형 분할로 오히려 수행 시간이 더 많이 걸림, 평균적으로 가장 빠름 (Java Arrays.sort() 내부 - Dual Pivot Quick Sort)

### 힙 정렬 (Heap Sort)

- 완전 이진 트리를 기본으로 하는 힙 자료구조를 기반으로 한 정렬 방식
- heapify(array, n, p) - 재귀적으로 작은 부모 스왑하고 더 진행 , 초기화 - 끝 부모(n/2-1) 부터 heapify, extract(swap 0,i) 하고 0부터 다시 heapify
- 시간 복잡도 : 최선, 최악, 평균 - O(N logN)
- 특징: 가장 크거나 가장 작은 값을 구할 때 주로 쓰임, 퀵 정렬과 합병 정렬의 성능이 좋기 때문에 사용 빈도가 높진 않음

## LRU Cache 구현
출처 
[https://doublesprogramming.tistory.com/254](https://doublesprogramming.tistory.com/254)
[https://0th-lab.tistory.com/6](https://0th-lab.tistory.com/6)

- Doubly Linked List + 해시 테이블
- head 에 가까운 데이터일수록 최근에 사용한 데이터, tail에 가까울수록 가장 오랫동안 사용하지 않은 데이터
- 삽입된 데이터를 사용하게 되면 head로 옮겨 우선순위를 높임
- 해시 테이블은 이중 연결 리스트에서 빠른 검색을 위해 사용된다 (접근의 성능 개선)
- 캐시에서 항복을 가져올 때, 해시 테이블을 참조해보고 없다면 캐시에 없다는 것을 의미
- Java의 LinkedHashMap
- O(1) 으로 구현하기 - 꼭 해보기! - [https://www.youtube.com/watch?v=WOaQfWqlV7A](https://www.youtube.com/watch?v=WOaQfWqlV7A)
