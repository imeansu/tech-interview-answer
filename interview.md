## HTTP의 GET과 POST 비교

- GET

    요청하는 데이터가 HTTP Request Message의 Header부분에 url이 담겨서 전송된다. url에 ? 뒤에 데이터가 붙어서 request가 보내지게 되어 url이라는 한정된 공간에 담겨가기 때문에 전송할 수 있는 데이터의 크기가 제한적이고 그대로 노출되기 때문에 비밀번호 같은 데이터에 대해서는 부적절하다

- POST

    HTTP Request Message의 Body 부분에 데이터가 담겨서 전송된다. 이 때문에 GET 방식보다는 전송할 수 있는 데이터의 크기가 크고 보안면에서 좀 더 낫다 (하지만, 암호화하지 않는 이상 비슷하다)

- GET은 서버에서 데이터를 가져오는 용도, POST는 서버의 값이나 상태를 변경, 추가하기 위해서 사용된다
- GET 방식은 브라우저에서 Caching 할 수 있기 때문에 POST 방식으로 요청해야 할 것을 보내는 데이터가 작고 보안적인 문제가 없다는 이유로 GET방식으로 요청한다면 기존에 Caching되었던 데이터가 응답될 가능성이 존재


## HTTP와 HTTPS

- HTTP 프로토콜
    - 개념
        - HyperText Transfer Protocol
        - 웹 상에서 클라이언트와 서버가 정보를 주고 받을 수 있도록 규약
        - TCP와 UDP를 사용하며, 80번 포트를 사용한다
            - 비연결성: 클라이언트가 요청하고 서버가 응답하면 연결이 끊어진다
            - 무상태(stateless): 요청과 응답이 있고난 이후에 서버는 아무런 상태도 저장하지 않는다
    - 문제점
        - TCP/IP는 도청이 가능하다: 평문이기 때문에 패킷을 수집하는 것만으로도 도청할 수 있다
        - 요청 상대를 확인하지 않기 때문에 위장이 가능하다: 누구인지, 허가된 상대인지, 어디서 보냈는지, 의미 없는 (DoS) 공격인지 확인할 수 없다
        - 완전성을 증명할 수 없다 → 변조가 가능하다: 중간자 공격을 당한다 하더라도 알길이 없다
- HTTPS 프로토콜
    - 개념
        - HyperText Transfer Protocol over Secure Socket Layer
        - 웹 통신 프로토콜인 HTTP에 보안이 강화된 프로토콜
        - 기본 TCP/IP로 443번 포트를 사용한다
        - SSL(Secure Socket Layer) or TLS(Transport Layer Security) 등 다른 프로토콜과 조합하여 암호화 한다

## 해시 (Hash)

- 해시함수: 데이터의 효율적 관리를 목적으로 임의의 길이의 데이터를 고저오딘 길이의 데이터로 매핑하는 함수
- 해시값의 개수보다 더 많은 키값을 해쉬값으로 변환하기 때문에 서로 다른 두 키에 대해 동일한 해시값을 내는 해시충돌을 발생시킴
- 색인(index)에 해시값을 사용함으로써 검색과 삽입, 삭제를 빠르게 할 수 있다 / 계산복잡성O(1)
- 모든 해시함수는 충돌을 일으킴, 해시충돌이 해시값 전체에 걸쳐 균등하게 발생하게끔 하는 것이 중요
- 해시충돌 문제 해결 아이디어
    1. chaining
        - 한 버킷당 들어갈 수 있는 엔트리의 수에 제한을 두지 않음(연결리스트로 저장), 유연하다는 장점이 있지만 메모리 문제를 야기할 수 있음
        - 계산복잡성: n(키)/m(해시테이블 크기) (균등하다면)
    2. open addressing
        - 들어있으면 다른 칸에
        - 그 칸에 값을 넣었다가 삭제하면 다음에 해시 충돌이 발생한적 없다고 생각하고 탐색을 끝낼 수 있음 따라서 DEL 등으로 표시해줘야 함
- 특정 해시값에 키가 몰리게 되면 효율성이 매우 떨어지게 됨
    - 선형 탐사: 고정폭으로 옮겨 엑세스
    - 제곱 탐사: 폭이 제곱수로 늘어남: 1**2, 2**2, 3**2
- 이중해싱: 탐사할 해시값의 규칙성을 없애버려서 clustering을 방지
    - 2개의 해시함수로 하나는 최소, 하나는 충돌시 탐사 이동폭을 얻기 위해

    → primary secondary clustering 모두 완화

- 알파(테이블이 차있는 비율)에 크게 영향을 받음


## 프로세스와 스레드

프로세스: 프로그램이 메모리에 올라가 CPU의 할당을 받을 수 있는 것

스레드: 프로세스 안의 여러 실행 단위 흐름

프로세스는 자신만의 고유한 공간과 자원을 할당받아 실행됨

스레드는 같은 프로세스 안 다른 스레드와 공간과 자원을 공유함

프로세스는 각각 별도의 주소공간 할당(독립적)

- Code: 코드 자체를 구성하는 메모리 영역
    - 컴파일된 후 기계어 형태
    - 실행코드(Instruction)
    - CPU는 코드 영역에 저장된 명령어를 하나씩 가져가서 처리
    - 읽기 전용
- Data: 전역변수, 정적변수, 배열 등
    - data: 초기화된 데이터
    - bss: 초기화 되지 않은 데이터
    - 전역 변수와 static 변수 등 저장 (메인 함수가 호출되기 전에 할당)
- Heap: 동적 할당 시 사용
    - new(), malloc() 등
    - 언어 마다 Heap에 저장하는 것이 약간 상이
    - 메소드 호출이 끝나도 사라지지 않고 유지 (GC에 의해서 지워지거나 JVM이 종료될 때까지)
    - 모든 Object 타입
    - 8가지 원시 타입을 제외한 모든 정의된 변수들은 참조 변수이다. 참조 변수는 실행될 때마다 많은 데이터들을 스택 메모리 영역에 뒀다 뺐다 하는게 비효율적이므로, 힙역역에 데이터값이 저장되고 스택메모리에는 간단하게 그 주소만 저장됨
- Stack: 지역변수, 매개변수, 리턴 값 (임시 메모리 영역)
    - heap영역에 생성된 Object 타입의 데이터들에 대한 참조를 위한 값이 할당
    - 8가지 원시 타입에 해당하는 지역변수, 매개변수
    - 메소드 종료되면 메모리가 해제

- 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없으며, 접근을 위해서는 IPC 통신이 필요하다
    - ex) 파이프, 파일, 소켓 등

스레드는 

- 스레드 ID, 프로그램 카운터, 레지스터 집합, 그리고 스택으로 구성
- 같은 프로세스에 속한 다른 스레드와 코드, 데이터 섹션, 그리고 열린 파일이나 신호와 같은 운영체제 자원들을 공유
- 스택을 스레드마다 독립적으로 할당하는 이유
    - 함수 호출 시 전달되는 인자, 되돌아갈 주소값 및 지역 변수 등을 저장하기 위해 사용되는 메모리 공간
    - 스택 메모리 공간이 독립적이라는 것은 독립적인 함수 호출이 가능하다는 것이고 이는 독립적인 실행 흐름이 추가되는 것

프로세스 제어 블록(Process Control Block, PCB)

- 운영체제의 자료구조
- 운영체제는 프로세스를 관리하기 위해 프로세스의 생성과 동시에 고유한 PCB를 생성
- 프로세스 전환이 발생하면 진행하던 작업을 저장하고 CPU를 반환해야 한느데, 이때 작업의 진행 상황을 모두 PCB에 저장. 그리고 다시 CPU를 할당받게 되면 PCB에 저장되어 있던 내용을 불러와 이전에 종료됐던 시점부터 다시 작업을 수행
- PCB에 저장되는 정보
    - 프로세스 식별자(Process ID, PID) : 프로세스 식별번호
    - 프로세스 상태 : new, ready, running, waiting, terminated 등의 상태를 저장
    - 프로그램 카운터 : 프로세스가 다음에 실행할 명령어의 주소
    - CPU 레지스터
    - CPU 스케쥴링 정보 : 프로세스의 우선순위, 스케줄 큐에 대한 포인터 등
    - 메모리 관리 정보 : 페이지 테이블 또는 세그먼트 테이블 등과 같은 정보를 포함
    - 입출력 상태 정보 : 프로세스에 할당된 입출력 장치들과 열린 파일 목록
    - 어카운팅 정보 : 사용된 CPU 시간, 시간제한, 계정번호 등

Context Switching 

- Cache 초기화
- Memory mapping 초기화
- 커널은 항상 실행되어야 한다

스레드는 Stack만 따로 할당 받고 나머지 영역은 서로 공유

하나의 프로세스가 생성될 때, 기본적으로 하나의 스레드 같이 생성

### 멀티프로세스

> 하나의 응용 프로그램을 여러 개의 프로세스로 구성하여 각 프로세스가 하나의 작업을 처리하도록 하는 것

장점: 안전성 (메모리 침범 문제를 OS 차원에서 해결 - 메모리 보호로 이냏 커널을 통해(시스템 콜 )통신이 이루어짐)

단점: 각각 독립된 메모리 영역을 갖고 있어, 작업량 많을 수록 오버헤드 발생. Context Switching으로 인한 성능 저하???

### 멀티스레드

> 하나의 응용 프로그램에서 여러 스레드를 구성해 각 스레드가 하나의 작업을 처리하는 것

스레드들이 공유 메모리를 통해 다수의 작업을 동시에 처리하도록 해줌

장점

- 독립적인 프로세스에 비해 공유 메모리만큼의 시간, 자원 손실이 감소
- 전역 변수와 정적 변수에 대한 자료 공유 가능
- 프로세스의 Context Switch와 다르게 캐시 메모리를 비울 필요가 없기 때문에 더 빠르다(프로세스 사이에는 공유하는 메로리가 하나도 없기 때문에 cs가 발생하면 캐쉬에 있는 모든 데이터를 리셋하고 다시 캐쉬 정보를 불러와야 함)

단점: 안전성(하나의 스레드가 데이터 공간을 망가뜨리면, 모든 스레드가 작동 불능 상태)

- 스레드를 많이 생성하면, Context Switching이 많이 일어나 성능 저하
    - 리눅스에서는 Thread를 Process와 같이 다룸
        - 가벼운 스레드, 자식 프로세스와 비슷한 방식으로 생성.
        - 부모 프로세스의 PCB 정보를 포함해 모두 갖지만 PCB 내 대부분의 정보가 포인터로 이루어짐
        - 부모 프로세스의 정보를 포인터로만 갖고 있고 몇몇 구조체에서만 자신이 쓰레드임을 알기 위한 다른 정보가 들어 있음
    - 스레드를 많이 생성하면, 모든 스레드를 스케쥴링해야 하므로, CS가 빈번하게 발생
- 멀티스레드의 안전성은 Critical Section 기법을 통해 대비함 (동기화 작업)

    하나의 스레드가 공유 데이터 값을 변경하는 시점에 다른 스레드가 그 값을 읽으려고 할 때 발생하는 문제를 해결하기 위한 동기화 과정

    상호 배제, 진행, 한정된 대기를 충족해야함

### Thread-safe

- 멀티스레드 환경에서 여러 스레드가 동시에 하나의 객체 및 변수(공유 자원)에 접근할 때, 의도한 대로 동작하는 것을 말한다
- 이러한 상황을 "Thread-safe하다"라고 표현
- Thread-safe 하게 구현하기
    - 이를 위해서는 공유 자원에 접근하는 임계영역(critical section)을 동기화 기법으로 제어해줘야 한다. 이를 '상호배제'라고 한다.
    - 동기화 기법으로는 뮤텍스, 세마포어가 존재
- Reentrant
    - 재진입성이라는 의미로, 어떤 함수가 Reentrant하다는 것은 여러 스레드가 동시에 접근해도 언제나 같은 실행 결과를 보장한다는 의미
    - 이를 만족하기 위해서는 해당 서브루틴에서는 공유자원을 사용하지 않으면 된다
        - 예) 정적 변수를 사용하거나 반환하면 안되고 호출 시 제공된 매개변수만으로 동작해야 한다
    - 따라서, Reentrant하다면 Thread-safe하지만 그 역은 성립하지 않는다

