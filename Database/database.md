## 데이터베이스의 개요 (개념, 기능, 스키마, DBMS, RDBMS)

### 데이터베이스의 개념

- 응용 시스템들이 데이터를 공유할 수 있도록 운영에 필요한 모든 데이터를 통합하여 컴퓨터에 저장한 데이터
- DB는 많은 인원, 다수의 시스템 또는 다수의 프로그램이 사용할 목적으로 통합하여 관리되는 자료의 집합
- 자료의 중복성 제거, 무결성 확보, 일관성 유지, 유용성 보장은 DB 관리의 핵심

### 데이터베이스의 기능

- 여러 사용자 간의 데이터 공유
- 데이터의 중복성 통제
- 사용자들에게 다양한 인터페이스 제공
- 권한 없는 사용자의 데이터 접근을 통제
- 데이터 간에 존재하는 복잡한 관련성을 쉽게 표현
- 데이터 간의 무결성을 보장하며, 백업과 복원 기능을 제공

### 스키마란

- 스키마는 데이터베이스의 구조와 제약 조건에 관한 전반적인 명세를 기술한 메타데이터의 집합
- 스키마는 데이터베이스를 구성하는 데이터 개체(Entity), 속성(Attribute), 관계(Relationship) 및 데이터 조작 시 데이터 값들이 갖는 제약 조건 등에 관해 전반적으로 정의
- 스키마는 사용자의 관점에 따라 외부 스키마, 개념 스키마, 내부 스키마로 나눠진다
- DBMS는 외부 스키마에 명세된 사용자의 요구를 개념 스키마 형태로 변환하고, 이를 다시 내부 스키마 형태로 변환

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/caeeae27-8297-4bde-8498-c9a9b5ebbcb2/Untitled.png)

### 스키마의 특징

- 데이터 사전(Data)에 저장되며, 다른 이름으로 메타데이터 라고도 한다
- 현실 세계의 특정한 한 부분의 표현으로서 특정 데이터 모델을 이용해서 만들어진다
- 시간에 따라 불변인 특성을 갖는다
- 데이터의 구조적 특성을 의미하며, 인스턴스에 의해 규정된다?

### 스키마의 3계층

1. 외부 스키마(External Schema) = 사용자 뷰(View)
    - 사용자나 응용프로그래머가 각 개인의 입장에서 필요로 하는 데이터베이스의 논리적 구조를 정의
    - 전체 DB의 한 논리적인 부분으로 볼 수 있으므로 서브 스키마(Sub Schema)라고도 한다
    - 하나의 DB 시스템에는 여러개의 외부 스키마가 존재할 수 있으며 하나의 외부 스키마를 여러개의 응용 프로그램이나 사용자가 공용할 수도 있다
    - 일반 사용자에게는 질의어를 이용해 DB를 쉽게 사용할 수 있도록 하고 응용 프로그래머는 언어를 사용해서 DB에 접근하도록 한다
2. 개념 스키마(Conceptual Schema) = 전체적인 뷰(View)
    - DB의 전체적인 논리적 구조로서, 모든 응용 프로그램이나 사용자들이 필요로 하는 데이터를 종합한 조직 전체의 DB로 하나만 존재한다
    - 개체간의 관계와 제약 조건을 나타내고 DB의 접근 권한, 보안 및 무결성 규칙에 관한 명세를 정의
    - DB 파일에 저당되는 데이터의 형태를 나타내는 것으로, 단순히 스키마라고 하면 개념 스키마를 의미
3. 내부 스키마(Internal Schema) = 저장 스키마(Storage Schema)
    - 물리적 자장장치의 입장에서 본 DB 구조로, 물리적인 저장 장치와 밀접한 계층
    - 실제로 DB에 저장될 레코드의 물리적인 구조를 정의하고, 저장 데이터 항목의 표현 방법, 내부 레코드의 물리적 순서 등을 나타낸다
    - 시스템 프로그래머나 시스템 설계자가 보는 관점

출처: [https://coding-factory.tistory.com/216](https://coding-factory.tistory.com/216)

### 데이터베이스 관리 시스템 (DBMS: Database Management System)

DBMS 정의

- 사용자와 응용 프로그램, 데이터베이스와 상호 작용하여 데이터를 저장하고 분석하기 위한 컴퓨터 응용프로그램
- DB 생성, 조회, 변경 등의 관리가 주요 기능
- 데이터 관리의 복잡성을 해결하는 동시에 데이터 추가, 변경, 검색, 삭제 및 백업 복구, 보안 등의 기능을 지원하는 소프트웨어
- DBMS는 조직의 목적을 위해 존재하는 운영 데이터를 통합 저장하여 공동으로 사용 가능하도록 관리하는 시스템

DBMS의 특징

- 데이터 무결성: 부적절한 자료가 입력되어 동일한 내용에 대하여 서로 다른 데이터가 저장되는 것을 허용하지 않는다
- 데이터 일관성: 삽입, 삭제, 갱신, 생성 후에도 저장된 데이터가 변함없이 일정해야 한다
- 데이터 회복성: 장애가 발생하였을 시 원래 상태로 복구되어야 한다
- 데이터 보안성: 불법적인 노출, 변경, 손실로부터 보호되어야 한다
- 데이터 효율성: 응답 시간, 저장 공간 활용 등이 최적화되어 사용자, 소프트웨어, 요구 조건 등을 만족시켜야 한다

출처: [https://velog.io/@cil05265/데이터베이스의-개요개념-기능-스키마DBMS-RDBMS](https://velog.io/@cil05265/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%9D%98-%EA%B0%9C%EC%9A%94%EA%B0%9C%EB%85%90-%EA%B8%B0%EB%8A%A5-%EC%8A%A4%ED%82%A4%EB%A7%88DBMS-RDBMS)

## 정규화
https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Database#%EC%A0%95%EA%B7%9C%ED%99%94%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C

### 배경

- 한 릴레이션에 여러 엔티티의 attribute를 혼합하게 되면 정보가 중복 저장되며, 저장공간을 낭비
- 중복된 정보로 인해 갱신 이상이 발생

### Anomaly (이상 현상)

> 예) {Student ID, Course ID, Department, Course ID, Grade}
> 
- 삽입 이상(Insertion Anomaly)
    - 원하지 않는 자료가 삽입된다든지, 삽입하는데 자료가 부족해 삽입이 되지 않아 발생하는 문제
    - 기본키가 (Student ID, Course ID) 인 경우 → Course를 수강하지 않은 학생은 Course ID가 없는 현상 발생. 결국 Course ID를 Null로 할 수밖에 없는데, 기본키는 Null이 될 수 없으므로, Table에 추가될 수 없음
    - 굳이 삽입하기 위해서는 '미수강'과 같은 Course ID를 만들어야 함
    - 불필요한 데이터를 추가해야지, 삽입할 수 있는 상황
- 삭제 이상(Deletion anomaly)
    - 하나의 자료만 삭제하고 싶지만, 그 자료가 포함된 튜플 전체가 삭제됨으로 원하지 않는 정보 손실이 발생하는 문제
    - 어떤 학생이 수강을 철회하는 경우, Student ID, Department 와 같은 학생에 대한 정보도 함께 삭제됨
    - 튜플 삭제로 인해 꼭 필요한 데이터까지 함께 삭제되는 문제
- 갱신 이상(Update anomaly)
    - 정확하지 않거나 일부의 튜플만 갱신되어 정보가 모호해지거나 일관성이 없어져 정확한 정보 파악이 되지 않는 문제
    - 학생의 전공이 "컴퓨터에서 음악"으로 바뀌는 경우, 모든 Department를 바꾸어야 함. 그러나 일부를 깜빡하고 바꾸지 못하는 경우, 제대로 파악하지 못함
    - 일부만 변경하여, 데이터가 불일치 하는 모순의 문제

### 정규화란?

> 관계형 데이터베이스에서 중복을 최소화하기 위해 데이터를 구조화하는 작업
> 
- 좀 더 구체적으로는 불만족스러운 나쁜 릴레이션의 attribute들을 나누어서 좋은 작은 릴레이션으로 분해하는 작업
- 정규화 과정을 거치게 되면 정규형을 만족. 정규형이란 특정 조건을 만족하는 릴레이션의 스키마의 형태를 말하며 제 1 정규형, 제 2 정규형, 제 3 정규형, .... 등이 존재한다

> '나쁜' 릴레이션은 어떻게 파악하는가?
> 
- 엔티티를 구성하고 있는 attribute 간에 함수적 종속성(Functional Dependency)을 판단
- 각각의 정규형마다 어떠한 함수적 종속성을 만족하는지에 따라 정규형이 정의

> 함수적 종속성이란?
> 
- X와 Y를 임의의 attribute 집합이라고 할 때, X의 값이 Y의 값을 유일하게(unique) 결정한다면 "X는 Y를 함수적으로 결정한다"라고 한다
- 각각의 정규형은 어떠한 조건을 만족해야 하는가?
    1. 분해의 대상인 분해 집합 D는 무손실 조인을 보장해야 한다
    2. 분해 집합 D는 함수적 종속성을 보존해야 한다

### 제 1 정규형 (1NF)

- attribute의 도메인이 오직 원자값 만을 포함하고, 튜플의 모든 attribute가 도메인에 속하는 하나의 값을 가져야 한다
- 테이블의 셀에 복합적인 값을 포함하지 않는다
- 이 정의에 반하는 테이블을 작성하는 것이 기술적으로 불가능하기 때문에 자동으로 만족

### 제 2정규형 (2NF)

- 부분함수 종속성이 존재하지 않아야 한다
- 모든 비주요 attribute들이 주요 attribute에 대해서 완전 함수적 종속이면 제 2 정규형을 만족한다고 볼 수 있다
- 완전 함수적 종속이란 X → Y 라고 가정했을 때, X의 어떠한 attribute라도 제거하면 더 이상 함수적 종속성이 성립하지 않는 경우를 말한다
- 제 2정규화의 대상은 복합키일 경우에만 해당. 즉 제 1정규형을 만족하면서도 기본키가 하나의 속성이라면 바로 제 2정규형 만족한다

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/44e75cf7-d089-48be-995f-b10360a2c914/Untitled.png)

출처: [https://jhnyang.tistory.com/358](https://jhnyang.tistory.com/358)

### 제 3정규형 (3NF)

- 어떠한 비주요 attribute도 기본키에 대해서 이행적으로 종속되지 않으면 제 3 정규형을 만족한다고 볼 수 있다.
- 이행 함수적 종속이란 X → Y, Y → Z의 경우에 의해서 추론될 수 있는 X → Z의 종속관계를 말한다. 즉, 비주요 attribute가 비주요 attribute에 의해 종속되는 경우가 없는 릴레이션 형태
- 제 2정규화가 복합키가 주키일 경우 목적에 따라 테이블을 분리해준다 하면 제 3정규화는 단일키가 주키인데 반복적 데이터가 많을 경우 이상을 대비해 테이블을 분리

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/183ca12d-0555-49a5-ab30-92d7690179bf/Untitled.png)

출처: [https://jhnyang.tistory.com/360](https://jhnyang.tistory.com/360)

### BCNF(Boyce-Codd) 정규형

- 여러 후보 키가 존재하는 릴레이션에 해당하는 정규화
- 복잡한 식별자 관계에 의해 발생하는 문제를 해결하기 위해 제 3정규형을 보완
- 후보키는 슈퍼키 중에서 최소성을 만족. 이 경우 {학생, 과목}. 교수가 정해지면(1교수 1과목 가정) 과목이 결정. 함수 종속성이 존재하기 때문에 BCNF를 만족하기 못함(교수는 후보키가 아니기 때문에???)
- 3NF를 만족하면서 BCNF를 만족하지 못하는 경우는 일반 컬럼이 후보키를 결정하는 경우

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ec5297ce-4a9b-419b-b67a-03948748237d/Untitled.png)

출처: [https://3months.tistory.com/193](https://3months.tistory.com/193)

### 정규화 장점

- DB 변경 시 이상 현상(Anomaly) 제거
- DB 구조 확장 시 재 디자인 최소화 - 새로운 데이터 형의 추가로 인한 확장 시, 그 구조를 변경하지 않아도 되거나 일부만 변경해도 됨 → 이는 DB와 연동도니 응용 프로그램에 최소한의 영향만 미치게 되며 응용 프로그램의 생명을 연장

### 정규화 단점

- 릴레이션의 분해로 인해 릴레이션 간의 연산(JOIN 연산)이 많아짐 → 질의에 대한 응답 시간이 느려질 수도 있음
- 정규화를 수행한다는 것은 데이터를 결정하는 결정자에 의해 함수적 종속을 가지고 있는 일반 속성을 의존자로 하여 이상 현상을 제거하는 것
- 데이터의 중복 속성을 제거하고 결정자에 의해 동일한 의미의 일반 속성이 하나의 테이블로 집약되므로 한 테이블의 데이터 용량이 최소화되는 효과 → 따라서 정규화된 테이블은 데이터를 처리할 때 속도가 빨라질 수도 있고 느려질 수도 있는 특성이 있다

### 단점에 대한 대응책

조회를 하는 SQL 문장에서 조인이 많이 발생하여 이로 인한 성능 저하가 나타나는 경우에 반정규화 전략 필요

**반정규화(De-normalization, 비정규화)**

- 정규화된 엔티티, 속성, 관계를 시스템의 성능 향상 및 개발과 운영의 단순화를 위해 중복 통합, 분리 드을 수행하는 데이터 모델링 기법
- 주의할 점: 반정규화를 과도하게 적용하다 보면 데이터의 무결성이 깨질 수 있다. 또한 입력, 수정, 삭제의 질의문에 대한 응답 시간이 늦어질 수 있다

## Locking

출처: [https://medium.com/pocs/동시성-제어-기법-잠금-locking-기법-319bd0e6a68a](https://medium.com/pocs/%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%A0%9C%EC%96%B4-%EA%B8%B0%EB%B2%95-%EC%9E%A0%EA%B8%88-locking-%EA%B8%B0%EB%B2%95-319bd0e6a68a)
         [https://sabarada.tistory.com/121](https://sabarada.tistory.com/121)

### 트랜잭션과 Lock

- 잠금
    - 동시성을 제어하기 위한 기능
    - 여러 커넥션에서 동시에 동일한 자원을 요청할 경우 순서대로 한 시점에는 하나의 커넥션만 변경할 수 있게 해주는 역할
- 트랜잭션
    - 데이터의 정합성을 보장하기 위한 기능
    - 하나의 논리적인 작업 셋 중 하나의 쿼리가 있든 두개 이상의 쿼리가 있든 관계없이 논리적인 작업 셋 자체가 100% 적용되거나 아무것도 적용되지 않아야 함을 보장
    - 예를 들어, HW 에러 또는 SW 에러와 같은 문제로 작업에 실패가 있을 경우, 특별한 대책이 피요하게 되는데 이러한 문제를 해결

### 동시성 제어(Concurrency Control)

> 다중 사용자 환경을 지원하는 데이터베이스 시스템에서 동시에 실행되는 여러 트랜잭션 간의 간섭으로 문제가 발행하지 않도록 트랜잭션의 실행 순서를 제어하는 기법
> 
- 갱신 분실(lost update) : 동일한 데이터를 동시에 갱신하느 경우 발생. 이전 트랜잭션이 데이터를 갱신한 후 트랜잭션이 종료하기 전에 나중 트랜잭션이 동일한 데이터를 갱신하여 갱신 값을 덮어쓰는 문제
- 연쇄 복귀(cascading rollback) or 회복 불가능(Unrecoverability) : 여러 개의 트랜잭션이 데이터를 공유할 때, 특정 트랜잭션이 이전 상태로 복귀할 경우 아무 문제 없는 다른 트랜잭션까지 연달아 복귀하게 되는 문제. 이때 한 트랜잭션이 이미 완료된 상태라면 트랜잭션의 지속성 조건에 따라 복귀 불가능
- 불일치 분석(inconsistent analysis) : 여러 개의 틀내잭션이 동시에 실행할 때 끼어들기로 인해 트랜잭션의 일관성이 유지되지 못하는 상황

### 잠금 기법

> 잠금(Locking)은 하나의 트랜잭션이 실행하는 동안 특정 데이터 항목에 대해서 다른 트랜잭션이 동시에 접근하지 못하도록 상호배제(Mutual Exclusive) 기능을 제공하는 기법
> 

잠금 연산의 종류

- 공유 잠금 (S-lock, Shared Lock)
    - 공유 잠금을 설정한 트랜잭션은 데이터 항목에 대해 읽기 연산(read)만 가능하다
    - 하나의 데이터 항목에 대해 여러 개의 공유잠금이 가능하다
- 배타 잠금 (X-lock, Exclusive Lock)
    - 데이터 항목에 대해서 일기 연산(read)와 쓰기 연산(write) 모두 가능
    - 하나의 데이터 항목에 대해서는 하나의 베타잠금(X-lock)만 가능
- S-lcok이나 X-lock 연산 실행 후에만 unlock 연산을 실행할 수 있음

### Lock의 설정 범위(Level)

- 데이터베이스
    - 1개의 세션만이 DB의 데이터에 접근
    - 일반적으로는 사용하지 않음
    - 사용하는 때가 있다면 DB의 소프트웨어 버전을 올린다던지 주요한 DB의 업데이트에 사용
- 테이블
    - 테이블을 기준이로 Lock
    - 테이블의 모든 행을 업데이트 하는 등의 전체 테이블에 영향을 주는 변경을 수행할 때 우요
    - 즉, DDL(create, alter, drop 등) 구문과 함께 사용되며 DDL Lock이라고 함
- 행(Row)
    - 행 수준의 Lock은 1개의 행(Row)를 기준으로 Lock 설정
    - DML에 대한 Lock으로 가장 일반적으로 사용

### 블로킹(Blocking)

- 블로킹은 Lock간의 경합이 발생하여 특정 Transaction이 작업을 진행하지 못하고 멈춰선 상태
- 주의 사항
    - 한 트랜잭션의 길이를 너무 길게 하는 것은 경합의 확률을 올린다
    - 처음부터 설계할 때 같은 데이터를 갱신하는 트랜잭션이 동시에 수행되지 않도록 해야 함
    - 트랜잭션 격리성 수준을 불필요하게 상향 조정하지 않는다
    - 쿼리를 오랜 시간 잡아두지 않도록 적절한 튜닝을 진행

### 잠금의 한계

- 직렬 가능한 스케줄이 항상 보장되지 않는다 → 2단계 잠금 규약(2PL)으로 해결
    
    **직렬 가능 스케줄이란 ?**
    
    - 직렬 스케줄에 따라 수행한 것과 같이 정확한 결과를 생성하는 비직렬 스케줄
    - 인터리빙 방식을 이용하여 여러 트랜잭션을 병행 수행하면서도, 정확한 결과를 얻을 수 있다
    - 직렬 가능 스케줄인지를 검사하기 보다는 직렬 간으성으로 보장하는 병행 제어 기법(Lock)을 사용
- 교착상태가 발생할 수 있다

### 2단계 잠금 규약(2-Phase Locking protocol : 2PL)

잠금을 설정하는 단계와 해제하는 단계로 나누어 수행

- 확장단계(growing phase) : 트랜잭션이 lock 연산만 수행할 수 있고 unlock 연산은 수행할 수 없는 단계
- 축소단계(shrinking phase) : 트랜잭션이 unlock 연산만 수행할 수 잇고 lock 연산은 수행할 수 없는 단계

문제점

- 교착상태 문제는 여전히 해결되지 않는다
    
    해결방법
    
    - 트랜잭션을 시작하기 전에 모든 필요한 잠금을 동시에 설정하는 방법
    - 교착상태 회피 방법이나 탐지 방법을 통해 해결
- 연쇄 복귀 문제도 발행할 수 있다
    - 이는 엄격한 2PL(strict 2PL)로 해결 가능
    
    **엄격한 2단계 잠금 규약**
    
    - 모든 X-lock에 대한 unlock 연산을 트랜잭션이 완전히 완료된 후에 실행하는 것
    - 완료되지 않은 트랜잭션에 의해 갱신된 데이터를 다른 트랜잭션이 읽거나 쓸 가능성을 원천적으로 봉쇄
    - 대부분의 DBMS에서 엄격한 2PL 규약을 이용하여 동시성 제어를 구현
