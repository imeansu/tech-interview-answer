## 데이터베이스의 개요 (개념, 기능, 스키마, DBMS, RDBMS)

### 데이터베이스의 개념

- 응용 시스템들이 데이터를 공유할 수 있도록 운영에 필요한 모든 데이터를 통합하여 컴퓨터에 저장한 데이터
- DB는 많은 인원, 다수의 시스템 또는 다수의 프로그램이 사용할 목적으로 통합하여 관리되는 자료의 집합
- 자료의 중복성 제거, 무결성 확보, 일관성 유지, 유용성 보장은 DB 관리의 핵심

### 데이터베이스의 기능

- 여러 사용자 간의 데이터 공유
- 데이터의 중복성 통제
- 사용자들에게 다양한 인터페이스 제공
- 권한 없는 사용자의 데이터 접근을 통제
- 데이터 간에 존재하는 복잡한 관련성을 쉽게 표현
- 데이터 간의 무결성을 보장하며, 백업과 복원 기능을 제공

### 스키마란

- 스키마는 데이터베이스의 구조와 제약 조건에 관한 전반적인 명세를 기술한 메타데이터의 집합
- 스키마는 데이터베이스를 구성하는 데이터 개체(Entity), 속성(Attribute), 관계(Relationship) 및 데이터 조작 시 데이터 값들이 갖는 제약 조건 등에 관해 전반적으로 정의
- 스키마는 사용자의 관점에 따라 외부 스키마, 개념 스키마, 내부 스키마로 나눠진다
- DBMS는 외부 스키마에 명세된 사용자의 요구를 개념 스키마 형태로 변환하고, 이를 다시 내부 스키마 형태로 변환

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/caeeae27-8297-4bde-8498-c9a9b5ebbcb2/Untitled.png)

### 스키마의 특징

- 데이터 사전(Data)에 저장되며, 다른 이름으로 메타데이터 라고도 한다
- 현실 세계의 특정한 한 부분의 표현으로서 특정 데이터 모델을 이용해서 만들어진다
- 시간에 따라 불변인 특성을 갖는다
- 데이터의 구조적 특성을 의미하며, 인스턴스에 의해 규정된다?

### 스키마의 3계층

1. 외부 스키마(External Schema) = 사용자 뷰(View)
    - 사용자나 응용프로그래머가 각 개인의 입장에서 필요로 하는 데이터베이스의 논리적 구조를 정의
    - 전체 DB의 한 논리적인 부분으로 볼 수 있으므로 서브 스키마(Sub Schema)라고도 한다
    - 하나의 DB 시스템에는 여러개의 외부 스키마가 존재할 수 있으며 하나의 외부 스키마를 여러개의 응용 프로그램이나 사용자가 공용할 수도 있다
    - 일반 사용자에게는 질의어를 이용해 DB를 쉽게 사용할 수 있도록 하고 응용 프로그래머는 언어를 사용해서 DB에 접근하도록 한다
2. 개념 스키마(Conceptual Schema) = 전체적인 뷰(View)
    - DB의 전체적인 논리적 구조로서, 모든 응용 프로그램이나 사용자들이 필요로 하는 데이터를 종합한 조직 전체의 DB로 하나만 존재한다
    - 개체간의 관계와 제약 조건을 나타내고 DB의 접근 권한, 보안 및 무결성 규칙에 관한 명세를 정의
    - DB 파일에 저당되는 데이터의 형태를 나타내는 것으로, 단순히 스키마라고 하면 개념 스키마를 의미
3. 내부 스키마(Internal Schema) = 저장 스키마(Storage Schema)
    - 물리적 자장장치의 입장에서 본 DB 구조로, 물리적인 저장 장치와 밀접한 계층
    - 실제로 DB에 저장될 레코드의 물리적인 구조를 정의하고, 저장 데이터 항목의 표현 방법, 내부 레코드의 물리적 순서 등을 나타낸다
    - 시스템 프로그래머나 시스템 설계자가 보는 관점

출처: [https://coding-factory.tistory.com/216](https://coding-factory.tistory.com/216)

### 데이터베이스 관리 시스템 (DBMS: Database Management System)

DBMS 정의

- 사용자와 응용 프로그램, 데이터베이스와 상호 작용하여 데이터를 저장하고 분석하기 위한 컴퓨터 응용프로그램
- DB 생성, 조회, 변경 등의 관리가 주요 기능
- 데이터 관리의 복잡성을 해결하는 동시에 데이터 추가, 변경, 검색, 삭제 및 백업 복구, 보안 등의 기능을 지원하는 소프트웨어
- DBMS는 조직의 목적을 위해 존재하는 운영 데이터를 통합 저장하여 공동으로 사용 가능하도록 관리하는 시스템

DBMS의 특징

- 데이터 무결성: 부적절한 자료가 입력되어 동일한 내용에 대하여 서로 다른 데이터가 저장되는 것을 허용하지 않는다
- 데이터 일관성: 삽입, 삭제, 갱신, 생성 후에도 저장된 데이터가 변함없이 일정해야 한다
- 데이터 회복성: 장애가 발생하였을 시 원래 상태로 복구되어야 한다
- 데이터 보안성: 불법적인 노출, 변경, 손실로부터 보호되어야 한다
- 데이터 효율성: 응답 시간, 저장 공간 활용 등이 최적화되어 사용자, 소프트웨어, 요구 조건 등을 만족시켜야 한다

출처: [https://velog.io/@cil05265/데이터베이스의-개요개념-기능-스키마DBMS-RDBMS](https://velog.io/@cil05265/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%9D%98-%EA%B0%9C%EC%9A%94%EA%B0%9C%EB%85%90-%EA%B8%B0%EB%8A%A5-%EC%8A%A4%ED%82%A4%EB%A7%88DBMS-RDBMS)

## 정규화
https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Database#%EC%A0%95%EA%B7%9C%ED%99%94%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C

### 배경

- 한 릴레이션에 여러 엔티티의 attribute를 혼합하게 되면 정보가 중복 저장되며, 저장공간을 낭비
- 중복된 정보로 인해 갱신 이상이 발생

### Anomaly (이상 현상)

> 예) {Student ID, Course ID, Department, Course ID, Grade}
> 
- 삽입 이상(Insertion Anomaly)
    - 원하지 않는 자료가 삽입된다든지, 삽입하는데 자료가 부족해 삽입이 되지 않아 발생하는 문제
    - 기본키가 (Student ID, Course ID) 인 경우 → Course를 수강하지 않은 학생은 Course ID가 없는 현상 발생. 결국 Course ID를 Null로 할 수밖에 없는데, 기본키는 Null이 될 수 없으므로, Table에 추가될 수 없음
    - 굳이 삽입하기 위해서는 '미수강'과 같은 Course ID를 만들어야 함
    - 불필요한 데이터를 추가해야지, 삽입할 수 있는 상황
- 삭제 이상(Deletion anomaly)
    - 하나의 자료만 삭제하고 싶지만, 그 자료가 포함된 튜플 전체가 삭제됨으로 원하지 않는 정보 손실이 발생하는 문제
    - 어떤 학생이 수강을 철회하는 경우, Student ID, Department 와 같은 학생에 대한 정보도 함께 삭제됨
    - 튜플 삭제로 인해 꼭 필요한 데이터까지 함께 삭제되는 문제
- 갱신 이상(Update anomaly)
    - 정확하지 않거나 일부의 튜플만 갱신되어 정보가 모호해지거나 일관성이 없어져 정확한 정보 파악이 되지 않는 문제
    - 학생의 전공이 "컴퓨터에서 음악"으로 바뀌는 경우, 모든 Department를 바꾸어야 함. 그러나 일부를 깜빡하고 바꾸지 못하는 경우, 제대로 파악하지 못함
    - 일부만 변경하여, 데이터가 불일치 하는 모순의 문제

### 정규화란?

> 관계형 데이터베이스에서 중복을 최소화하기 위해 데이터를 구조화하는 작업
> 
- 좀 더 구체적으로는 불만족스러운 나쁜 릴레이션의 attribute들을 나누어서 좋은 작은 릴레이션으로 분해하는 작업
- 정규화 과정을 거치게 되면 정규형을 만족. 정규형이란 특정 조건을 만족하는 릴레이션의 스키마의 형태를 말하며 제 1 정규형, 제 2 정규형, 제 3 정규형, .... 등이 존재한다

> '나쁜' 릴레이션은 어떻게 파악하는가?
> 
- 엔티티를 구성하고 있는 attribute 간에 함수적 종속성(Functional Dependency)을 판단
- 각각의 정규형마다 어떠한 함수적 종속성을 만족하는지에 따라 정규형이 정의

> 함수적 종속성이란?
- X → Y : 릴레이션 R에서 X값을 알면 Y를 알 수 있고, X 값에 의해 Y값이 달라질 때, Y는 X에 함수적 종속
- X와 Y를 임의의 attribute 집합이라고 할 때, X의 값이 Y의 값을 유일하게(unique) 결정한다면 "X는 Y를 함수적으로 결정한다"라고 한다
- 각각의 정규형은 어떠한 조건을 만족해야 하는가?
    1. 분해의 대상인 분해 집합 D는 무손실 조인을 보장해야 한다
    2. 분해 집합 D는 함수적 종속성을 보존해야 한다

### 제 1 정규형 (1NF)

- attribute의 도메인이 오직 원자값 만을 포함하고, 튜플의 모든 attribute가 도메인에 속하는 하나의 값을 가져야 한다
- 테이블의 셀에 복합적인 값을 포함하지 않는다
- 이 정의에 반하는 테이블을 작성하는 것이 기술적으로 불가능하기 때문에 자동으로 만족

### 제 2정규형 (2NF)

- 부분함수 종속성이 존재하지 않아야 한다
- 모든 비주요 attribute들이 주요 attribute에 대해서 완전 함수적 종속이면 제 2 정규형을 만족한다고 볼 수 있다
- 완전 함수적 종속이란 X → Y 라고 가정했을 때, X의 어떠한 attribute라도 제거하면 더 이상 함수적 종속성이 성립하지 않는 경우를 말한다
- 제 2정규화의 대상은 복합키일 경우에만 해당. 즉 제 1정규형을 만족하면서도 기본키가 하나의 속성이라면 바로 제 2정규형 만족한다

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/44e75cf7-d089-48be-995f-b10360a2c914/Untitled.png)

출처: [https://jhnyang.tistory.com/358](https://jhnyang.tistory.com/358)

### 제 3정규형 (3NF)

- 어떠한 비주요 attribute도 기본키에 대해서 이행적으로 종속되지 않으면 제 3 정규형을 만족한다고 볼 수 있다.
- 이행 함수적 종속이란 X → Y, Y → Z의 경우에 의해서 추론될 수 있는 X → Z의 종속관계를 말한다. 즉, 비주요 attribute가 비주요 attribute에 의해 종속되는 경우가 없는 릴레이션 형태
- 제 2정규화가 복합키가 주키일 경우 목적에 따라 테이블을 분리해준다 하면 제 3정규화는 단일키가 주키인데 반복적 데이터가 많을 경우 이상을 대비해 테이블을 분리

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/183ca12d-0555-49a5-ab30-92d7690179bf/Untitled.png)

출처: [https://jhnyang.tistory.com/360](https://jhnyang.tistory.com/360)

### BCNF(Boyce-Codd) 정규형

- 여러 후보 키가 존재하는 릴레이션에 해당하는 정규화
- 후보키가 아닌 결정자 제거, 모든 결정키가 후보키
- 복잡한 식별자 관계에 의해 발생하는 문제를 해결하기 위해 제 3정규형을 보완
- 후보키는 슈퍼키 중에서 최소성을 만족. 이 경우 {학생, 과목}. 교수가 정해지면(1교수 1과목 가정) 과목이 결정. 함수 종속성이 존재하기 때문에 BCNF를 만족하기 못함(교수는 후보키가 아니기 때문에???)
- 3NF를 만족하면서 BCNF를 만족하지 못하는 경우는 일반 컬럼이 후보키를 결정하는 경우

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ec5297ce-4a9b-419b-b67a-03948748237d/Untitled.png)

출처: [https://3months.tistory.com/193](https://3months.tistory.com/193)

### 정규화 장점

- DB 변경 시 이상 현상(Anomaly) 제거
- DB 구조 확장 시 재 디자인 최소화 - 새로운 데이터 형의 추가로 인한 확장 시, 그 구조를 변경하지 않아도 되거나 일부만 변경해도 됨 → 이는 DB와 연동도니 응용 프로그램에 최소한의 영향만 미치게 되며 응용 프로그램의 생명을 연장

### 정규화 단점

- 릴레이션의 분해로 인해 릴레이션 간의 연산(JOIN 연산)이 많아짐 → 질의에 대한 응답 시간이 느려질 수도 있음
- 정규화를 수행한다는 것은 데이터를 결정하는 결정자에 의해 함수적 종속을 가지고 있는 일반 속성을 의존자로 하여 이상 현상을 제거하는 것
- 데이터의 중복 속성을 제거하고 결정자에 의해 동일한 의미의 일반 속성이 하나의 테이블로 집약되므로 한 테이블의 데이터 용량이 최소화되는 효과 → 따라서 정규화된 테이블은 데이터를 처리할 때 속도가 빨라질 수도 있고 느려질 수도 있는 특성이 있다

### 단점에 대한 대응책

조회를 하는 SQL 문장에서 조인이 많이 발생하여 이로 인한 성능 저하가 나타나는 경우에 반정규화 전략 필요

**반정규화(De-normalization, 비정규화)**

- 정규화된 엔티티, 속성, 관계를 시스템의 성능 향상 및 개발과 운영의 단순화를 위해 중복 통합, 분리 드을 수행하는 데이터 모델링 기법
- 주의할 점: 반정규화를 과도하게 적용하다 보면 데이터의 무결성이 깨질 수 있다. 또한 입력, 수정, 삭제의 질의문에 대한 응답 시간이 늦어질 수 있다

## 트랜잭션
https://d2.naver.com/helloworld/407507

- 작업의 완전성을 보장해주는 것
- 논리적인 작업 셋을 모두 완벽하게 처리하거나 또는 처리하지 못할 경우에는 원 상태로 복구해서 작업의 잉ㄹ부분만 적용되는 현상이 발행하지 않게 만들어주는 기능
- 사용자 입장 - 작업의 논리적인 단위, 시스템 입장 - 데이터들을 접근 또는 변경하는 프로그램의 단위

트랜잭션과 Lock

- 잠금은 동시성을 제어하기 위한 기능
- 트랜잭션은 데이터의 정합성을 보장하기 위한 기능
- 여러 커넥션에서 동시에 동일한 자원을 요청할 경우 순서대로 한 시점에는 하나의 커넥션만 변경할 수 있게 해주는 역할

트랜잭션의 특성: ACID 4가지 특성을 만족해야 함

- 원자성(Atomicity): 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 함
- 일관성(Consistency): 데이터베이스에는 오브젝트에 대한 각종 정합성 제약을 추가할 수 있고 데이터 조작 전후에 그 상태를 유지하는 것을 보증하는 것 (트랜잭션은 유효한 상태로만 변경될 수 있음) (ex. 유니크 제약을 설정한 속성이 유지)
- 고립성(Isolation): 일련의 데이터 조작을 복수 사용자가 동시에 실행해도 각각의 처리가 모순 없이 실행되는 것을 보증
- 지속성(Durability): 일련의 데이터 조작을 완료하고 완료 통지를 사용자가 받는 시점에서 그 조작이 영구적이 되어 그 결과를 잃지 않는 것을 나타냅니다

트랜잭션의 상태

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/13305f42-3761-4d96-8f5b-d7e185d84df1/Untitled.png)

- Active: 트랜잭션의 활동 상태. 트랜잭션이 실행 중이며 동작 중인 상태를 말한다
- Failed: 트랜잭션 실패 상태. 트랜잭션이 더이상 정상적으로 진행할 수 없는 상태
- Partially Committed: 트랜잭션의 Commit 명령이 도착한 상태. 트랜잭션의 commit 이전 sql 문이 수행되고 commit만 남은 상태를 말한다
- Committed: 트랜잭션 완료 상태. 트랜잭션이 정상적으로 완료된 상태
- Aborted: 트랜잭션이 취소 상태. 트랜잭션이 취소되고 트랜잭션 실행 이전 데이터로 돌아간 상태

Commit 요청이 들어오면 Partical Commited 상태가 된다. 이후 Commit을 문제없이 수행할 수 있으면 Committed 상태로 전이되고, 만약 오류가 발생하면 Failed 상태가 된다.


## Locking

출처
[https://medium.com/pocs/동시성-제어-기법-잠금-locking-기법-319bd0e6a68a](https://medium.com/pocs/%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%A0%9C%EC%96%B4-%EA%B8%B0%EB%B2%95-%EC%9E%A0%EA%B8%88-locking-%EA%B8%B0%EB%B2%95-319bd0e6a68a)
[https://sabarada.tistory.com/121](https://sabarada.tistory.com/121)

### 트랜잭션과 Lock

- 잠금
    - 동시성을 제어하기 위한 기능
    - 여러 커넥션에서 동시에 동일한 자원을 요청할 경우 순서대로 한 시점에는 하나의 커넥션만 변경할 수 있게 해주는 역할
- 트랜잭션
    - 데이터의 정합성을 보장하기 위한 기능
    - 하나의 논리적인 작업 셋 중 하나의 쿼리가 있든 두개 이상의 쿼리가 있든 관계없이 논리적인 작업 셋 자체가 100% 적용되거나 아무것도 적용되지 않아야 함을 보장
    - 예를 들어, HW 에러 또는 SW 에러와 같은 문제로 작업에 실패가 있을 경우, 특별한 대책이 피요하게 되는데 이러한 문제를 해결

### 동시성 제어(Concurrency Control)

> 다중 사용자 환경을 지원하는 데이터베이스 시스템에서 동시에 실행되는 여러 트랜잭션 간의 간섭으로 문제가 발행하지 않도록 트랜잭션의 실행 순서를 제어하는 기법
> 
- 갱신 분실(lost update) : 동일한 데이터를 동시에 갱신하느 경우 발생. 이전 트랜잭션이 데이터를 갱신한 후 트랜잭션이 종료하기 전에 나중 트랜잭션이 동일한 데이터를 갱신하여 갱신 값을 덮어쓰는 문제
- 연쇄 복귀(cascading rollback) or 회복 불가능(Unrecoverability) : 여러 개의 트랜잭션이 데이터를 공유할 때, 특정 트랜잭션이 이전 상태로 복귀할 경우 아무 문제 없는 다른 트랜잭션까지 연달아 복귀하게 되는 문제. 이때 한 트랜잭션이 이미 완료된 상태라면 트랜잭션의 지속성 조건에 따라 복귀 불가능
- 불일치 분석(inconsistent analysis) : 여러 개의 틀내잭션이 동시에 실행할 때 끼어들기로 인해 트랜잭션의 일관성이 유지되지 못하는 상황

### 잠금 기법

> 잠금(Locking)은 하나의 트랜잭션이 실행하는 동안 특정 데이터 항목에 대해서 다른 트랜잭션이 동시에 접근하지 못하도록 상호배제(Mutual Exclusive) 기능을 제공하는 기법
> 

잠금 연산의 종류

- 공유 잠금 (S-lock, Shared Lock)
    - 공유 잠금을 설정한 트랜잭션은 데이터 항목에 대해 읽기 연산(read)만 가능하다
    - 하나의 데이터 항목에 대해 여러 개의 공유잠금이 가능하다
- 배타 잠금 (X-lock, Exclusive Lock)
    - 데이터 항목에 대해서 일기 연산(read)와 쓰기 연산(write) 모두 가능
    - 하나의 데이터 항목에 대해서는 하나의 베타잠금(X-lock)만 가능
- S-lcok이나 X-lock 연산 실행 후에만 unlock 연산을 실행할 수 있음

### Lock의 설정 범위(Level)

- 데이터베이스
    - 1개의 세션만이 DB의 데이터에 접근
    - 일반적으로는 사용하지 않음
    - 사용하는 때가 있다면 DB의 소프트웨어 버전을 올린다던지 주요한 DB의 업데이트에 사용
- 테이블
    - 테이블을 기준이로 Lock
    - 테이블의 모든 행을 업데이트 하는 등의 전체 테이블에 영향을 주는 변경을 수행할 때 우요
    - 즉, DDL(create, alter, drop 등) 구문과 함께 사용되며 DDL Lock이라고 함
- 행(Row)
    - 행 수준의 Lock은 1개의 행(Row)를 기준으로 Lock 설정
    - DML에 대한 Lock으로 가장 일반적으로 사용

### 블로킹(Blocking)

- 블로킹은 Lock간의 경합이 발생하여 특정 Transaction이 작업을 진행하지 못하고 멈춰선 상태
- 주의 사항
    - 한 트랜잭션의 길이를 너무 길게 하는 것은 경합의 확률을 올린다
    - 처음부터 설계할 때 같은 데이터를 갱신하는 트랜잭션이 동시에 수행되지 않도록 해야 함
    - 트랜잭션 격리성 수준을 불필요하게 상향 조정하지 않는다
    - 쿼리를 오랜 시간 잡아두지 않도록 적절한 튜닝을 진행

### 잠금의 한계

- 직렬 가능한 스케줄이 항상 보장되지 않는다 → 2단계 잠금 규약(2PL)으로 해결
    
    **직렬 가능 스케줄이란 ?**
    
    - 직렬 스케줄에 따라 수행한 것과 같이 정확한 결과를 생성하는 비직렬 스케줄
    - 인터리빙 방식을 이용하여 여러 트랜잭션을 병행 수행하면서도, 정확한 결과를 얻을 수 있다
    - 직렬 가능 스케줄인지를 검사하기 보다는 직렬 간으성으로 보장하는 병행 제어 기법(Lock)을 사용
- 교착상태가 발생할 수 있다

### 2단계 잠금 규약(2-Phase Locking protocol : 2PL)

잠금을 설정하는 단계와 해제하는 단계로 나누어 수행

- 확장단계(growing phase) : 트랜잭션이 lock 연산만 수행할 수 있고 unlock 연산은 수행할 수 없는 단계
- 축소단계(shrinking phase) : 트랜잭션이 unlock 연산만 수행할 수 잇고 lock 연산은 수행할 수 없는 단계

문제점

- 교착상태 문제는 여전히 해결되지 않는다
    
    해결방법
    
    - 트랜잭션을 시작하기 전에 모든 필요한 잠금을 동시에 설정하는 방법
    - 교착상태 회피 방법이나 탐지 방법을 통해 해결
- 연쇄 복귀 문제도 발행할 수 있다
    - 이는 엄격한 2PL(strict 2PL)로 해결 가능
    
    **엄격한 2단계 잠금 규약**
    
    - 모든 X-lock에 대한 unlock 연산을 트랜잭션이 완전히 완료된 후에 실행하는 것
    - 완료되지 않은 트랜잭션에 의해 갱신된 데이터를 다른 트랜잭션이 읽거나 쓸 가능성을 원천적으로 봉쇄
    - 대부분의 DBMS에서 엄격한 2PL 규약을 이용하여 동시성 제어를 구현

## 인덱스

### 인덱스의 중요성

- 레인지 스캔을 실행하려면 인덱스가 꼭 필요
- 적정한 인덱스가 없다면 DB는 어쩔 수 없이 풀 스캔을 해야 함
- 인덱스를 사용하지만 풀 스캔이 빠르다고 옵티마이저에서 판단하면 인덱스를 사용하지 않은 경우도 있음

### 인덱스의 장점

- SQL 문을 변경하지 않아도 성능을 개선할 수 있다
- 테이블의 데이터에 영향을 주지 않는다
- 일정한 효과를 기대할 수 있다
- 사용하면 좋은 경우
    - Where 절에서 자주 사용되는 Column
    - 외래키가 사용되는 Column
    - Join에 자주 사용되는 Column

### 인덱스의 구조

- 일반적으로 B-tree 구조를 갖는다. B-tree 는 관계형 DB 에서 튜닝의 기본이 되는 인덱스
- B-tree 는 반드시 데이터를 정렬된 상태로 유지. 즉, 순서를 유지하고 있는 것이 B-tree 의 핵심
- SELECT 질의 조건에는 부등호 연산(<>)도 포함
- hash table 은 동등 연산에 특화된 자료구조이기 때문에 부등호 연산 사용 시 문제 발생

### 인덱스의 작성이 역효과 나는 경우

- 인덱스의 갱신의 오버헤드로 갱신 처리의 성능이 떨어진다 (DML이 자주 일어나는 Column)
    - INSERT
        - 테이블에는 입력 순서대로 저장되지만, 인덱스 테이블에는 정렬하여 저장하기 때문에 성능 저하
        - index split : 인덱스의 Block들이 하나에서 두 개로 나누어지는 현상
        - 기존 블록에 여유 공간이 없는 상황에서 새로운 데이터가 입력되면, 기존 블록 중 일부를 새 블록에다가 기록한 후, 기존 블록에 빈 공간을 만들어서 새로운 데이터를 추가
        - 새로운 블록을 할당받고 Key를 옮기는 모든 수행 과정이 Redo에 기록되고 많은 양의 Redo를 유발
        - index split이 이루어지는 동안 해당 블록에 대해 키 값이 변경되면 안되므로 DML이 블로킹
    - DELETE : 테이블에서만 삭제되고 인덱스 테이블에는 남아있어 쿼리 수행 속도 저하
    - UPDATE : 인덱스에는 UPDATE가 없기 때문에 DELETE, INSERT 두 작업 수행하여 부하 발생
- 의도한 것과 다른 인덱스가 사용된다
    - 테이블에 복수의 인덱스를 작성한 경우 발생
    - 인덱스 후보가 많으면 옵티마이저도 헤매게 됨

### 인덱스를 만들 때 기준

- 크기가 큰 테이블에만 만든다
    - 작은 테이블은 풀 스캔과 차이가 없음
- 기본키 제약이나, 유일성 제약이 부여된 열에는 불필요하다
    - 자동 생성
- Cardinality 높은 열에 만든다
    - 운전면허증 번호>>>>>>넘을 수 없는 벽>>>>행정구역>성별
    - 운전면허는 Cardinality 가 높다

### Composite Index

- 인덱스로 설정하는 필드의 속성이 중요
- title, author 이 순서로 인덱스를 설정한다면, title을 search하는 경우 index의 효과를 볼 수 있지만 author만으로 search하는 경우, index를 생성한 것이 소용 없어짐

### clustered index vs non-clustered index
출처
[https://gocoder.tistory.com/1826](https://gocoder.tistory.com/1826), 
[https://m.blog.naver.com/islove8587/220431192221](https://m.blog.naver.com/islove8587/220431192221)

1. 클러스터드 인덱스
    - 인덱스를 생성할 때는 데이터 페이지 전체를 다시 정렬
    - 인덱스 자체가 데이터 페이지. 인덱스 자체에 데이터가 포함
    - 비클러스터드 인덱스보다 검색 속도는 빠르지만 입력/수정/삭제는 느림
    - 테이블에 한 개만 생성 가능
    - 30% 이내 사용 권장
    - Primary key 등
2. 비클러스터드 인덱스
    - 별도의 페이지에 인덱스 테이블을 생성하여 데이터를 정렬
    - 검색 속도는 느리지만, 데이터의 입력/수정/삭제가 더 빠르다
    - 남용할 경우 시스템 성능을 떨어뜨리는 결과
    - 3% 이내 사용 권장
## 파티셔닝과 샤딩
출처
[https://nesoy.github.io/articles/2018-05/Database-Shard](https://nesoy.github.io/articles/2018-05/Database-Shard)
[https://moonsbeen.tistory.com/27](https://moonsbeen.tistory.com/27)
[https://galid1.tistory.com/797](https://galid1.tistory.com/797)
[https://seokbeomkim.github.io/posts/partition-and-sharding/](https://seokbeomkim.github.io/posts/partition-and-sharding/)

> DB 크기가 증가하며 VLDB(Very Large DBMS)가 등장했고 여러 테이블을 관리하며 생기는 성능 이슈를 해결하기 위해 파티셔닝과 샤딩이 나옴
> 

### 파티셔닝과 샤딩의 차이점

- 샤딩과 파티셔닝 모두, 큰 데이터를 여러 서브셋으로 나누어 저장하는 기술
- 파티셔닝은 큰 테이블을 하나의 인스턴스의 여러 테이블에 나누어 저장
- 샤딩은 서브셋을 여러 인스턴스에 저장

### 파티셔닝

- 큰 테이블이나 인덱스를 관리하기 쉬운 크기로 분리하는 방법
- 장점
    - 가용성(Availability): 물리적인 노드 분리에 따라 전체 DB 내의 데이터 손상 가능성이 줄어들고, 데이터 가용성이 향상된다
    - 관리 용이성(Manageability): 큰 테이블을 제거하여 관리를 쉽게 할 수 있다
    - 성능(Performance): 특정 DML과 Query 성능을 향상시키며 대용량 데이터 write 환경에서 효율적
- 단점
    - 테이블 간 join 비용 증가
    - 파티션 제약: 테이블과 인덱스를 별도로 파티션할 수 없다

### 샤딩

- 물리적으로 다른 데이터베이스에 데이터를 수평 분할 방식으로 분산 저장하고 조회하는 방법
- 장점
    - 쿼리를 여러 인스턴스로 분산하여 처리 → 성능과 확장성
    - 데이터의 개수가 작아지고 따라서 인덱스의 개수도 작아져 성능이 향상된다
    - 데이터 훼손 가능성이 줄어든다
- 단점
    - 타겟쿼리와 브로드캐스트 쿼리
        - 데이터를 찾는 과정이 기존보다 복잡
        - 쿼리에 적절한 샤드키가 포함되지 않는다면, 모든 노드들로 쿼리를 요청(브로드캐스트 쿼리)하고 이를 다시 취합하여 응답하게 된다
        - 반대로 적절한 샤드키를 지정한다면, 해당 데이터가 존재하는 인스턴스를 찾아 타겟쿼리를 하게 된다
    - 적절한 샤드키
        - 샤드키를 잘못 선정하면 데이터가 한쪽으로 치우치게 되고 쿼리도 몰리게 됨
    - 적절한 샤드키를 선정하여 데이터가 고르고 쿼리를 적절히 분배할 수 있도록 해야 함
    - 두 개 이상의 샤드에 대한 JOIN 연산을 할 수 없다
    - auto increment 등은 샤드 별로 달라질 수 있다
    - last_insert_id() 값은 유효하지 않다
    - shard key column 값은 update하면 안된다
    - 하나의 트랜잭션에서 두 개 이상의 샤드에 접근할 수 없다

## RDB vs NoSQL

### RDB (관계형 DB)

- SQL을 사용하면 RDBMS에서 데이터를 저장, 수정, 삭제 및 검색 할 수 있음
- 두 가지 핵심 특징
    - 데이터는 정해진 데이터 스키마에 따라 테이블에 저장된다
    - 데이터는 관계를 통해 여러 테이블에 분산된다 → 중복을 피하기 위해
- 하나의 테이블에서 중복 없이 하나의 데이터만을 관리하기 때문에 다른 테이블에서 부정확한 데이터를 다룰 위험이 없어지는 장점이 있음
- 속도보다 트렌잭션시의 ACID가 중요
- 장점
    - 명확하게 정의된 스키마, 데이터 무결성 보장
    - 관계는 각 데이터를 중복없이 한번만 저장 → 쓰기 속도 빠름
    - Undo와 Redo 제공
- 단점
    - 덜 유연함. 데이터 스키마를 사전에 계획하고 알려야 함 (나중에 수정하기 힘듦)
    - 관계를 맺고 있어서 조인문이 많은 복잡한 쿼리가 만들어질 수 있음
    - 대체로 수직적 확장만 가능

### NoSQL (비관계형 DB)

- 스키마도, 관계도 없다
- 장점
    - 스키마가 없어서 유연함. 언제든지 저장된 데이터를 조정하고 새로운 필드 추가 가능
    - 데이터는 애플리케이션이 필요로 하는 형식으로 저장됨. 데이터 읽어오는 속도 빨라짐 (epdlxj wndqhrdl rksmd)
    - 수직 및 수평 확장이 가능해서 애플리케이션이 발생시키는 모든 읽기/쓰기 요청 처리 가능
- 단점
    - 유연성으로 인해 데이터 구조 결정을 미루게 될 수 있음
    - 데이터 중복을 계속 업데이트 해야 함
    - 데이터가 여러 컬렉션에 중복되어 있기 때문에 수정 시 모든 컬렉션에서 수행해야 함 (SQL에서는 중복 데이터가 없으므로 한번만 수행이 가능)
    - 트랜잭션 미제공

### 확장 개념

- 수직적 확장: 단순히 데이터베이스 서버의 성능을 향상시키는 것 (ex. CPU 업그레이드)
- 수평적 확장: 더 많은 서버가 추가되고 데이터베이스가 전체적으로 분산됨
- RDB는 데이터 저장 방식으로 인해 수직적 확장, NoSQL은 수평적 확장

### 선택시 고려사항 (~사용이 더 좋을 때)

1. RDB
    - 관계를 맺고 있는 데이터가 자주 변경되는 애플리케이션의 경우
    - 변경될 여지가 없고, 명확한 스키마가 사용자와 데이터에게 중요한 경우
2. NoSQL
    - 정확한 데이터 구조를 알 수 없거나 변경/확장 될 수 있는 경우
    - 읽기를 자주 하지만, 데이터 변경은 자주 없는 경우
    - 데이터베이스를 수평으로 확장해야 하는 경우 (막대한 양의 데이터를 다뤄야 하는 경우)

## NoSQL
출처
[https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Database#nosql](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Database#nosql)
[https://ohjongsung.io/2019/05/01/cap-이론과-pacelc-이론](https://ohjongsung.io/2019/05/01/cap-%EC%9D%B4%EB%A1%A0%EA%B3%BC-pacelc-%EC%9D%B4%EB%A1%A0)
[https://armful-log.tistory.com/56](https://armful-log.tistory.com/56)

### 정의

관계형 데이터 모델을 지양 하며 대량의 분산된 데이터를 저장하고 조회하는 데 특화되었으며 스키마 없이 사용 가능하거나 느슨한 스키마를 제공하는 저장소

### 특징

- 종류마다 쓰기/읽기 성능 특화, 2차 인덱스 지원, 오토 샤딩 지원 같은 고유한 특징을 가진다
- 대량의 데이터를 빠르게 처리하기 위해 메모리에 임시 저장하고 응답하는 등의 방법을 사용
- 동적인 스케일 아웃을 지원하기도 하며, 가용성을 위하여 데이터 복제 등의 방법으로 관계형 데이터베이스가 제공하지 못하는 성능과 특징을 제공

### CAP 이론

분산 데이터베이스 시스템에서 CAP 세가지 속성 모두 만족하는 것은 불가능 하며, 오직 2가지만 만족할 수 있다

1. 일관성(Consistency)
    - 다중 클라이언트에서 같은 시간에 조회하는 데이터는 항상 동일한 데이터임을 보증하는 것
    - 일부 NoSQL은 데이터의 일관성이 느슨하게 처리되어 동일한 데이터가 나타나지 않을 수 있다
    - 데이터의 변경을 시간의 흐름에 따라 여러 노드로 전파 → 궁극적 일관성을 지원하다고도 한다
    - 각 NoSQL 들은 분산 노드 간의 데이터 동기화를 위해 두 가지 방법을 사용
        - 동기식: 클라이언트에 응답하기 전에 모든 노드에 데이터를 저장 - 정합성 보장
        - 비동기식: 메모리나 임시 파일에 기록하고 클라이언트에 먼저 응답한 다음, 특정 이벤트 또는 프로세스를 사용하여 노드로 데이터를 동기화 - 쓰기 노드에 장애가 발생하였을 경우 데이터 손실 가능
2. 가용성(Availability)
    - 모든 요청은 정상 응답을 받는다
    - 모든 클라이언트의 읽기와 쓰기 요청에 대하여 항상 응답이 가능해야 함을 보증
    - 내고장성을 가진 NoSQL은 클러스터 내에서 몇개의 노드가 망가지더라도 정상적인 서비스 가능
    - 몇몇 NoSQL은 가용성을 보장하기 위해 데이터 복제(Replication) 사용
3. 네트워크 분할 허용성(Partition tolerance)
    - 노드 간  통신이 실패하는 경우라도 시스템은 정상 동작 한다
    - 지역적으로 분할된 네트워크 환경에서 동작학하는 시스템에서 두 지역 간의 네트워크가 단절되거나 네트워크 데이터의 유실이 일어나더라도 각 지역내의 시스템은 정상적으로 동작해야 함

### CAP 분류

1. CA 시스템 (MySQL)
    - 네트워크 장애를 허용하지 않는다 → 파티션하지 않는다 → RDB
2. CP 시스템 (MongoDB)
    - 완벽한 일관성을 갖는 분산 시스템에서 데이터 변경은 존재하는 모든 노드에 복제되어야 완료
    - 노드가 늘어날수록 지연 시간 길어짐
3. AP 시스템 (Cassandra)
    - 모든 노드가 어떤 상황에서도 응답 → 일관성이 깨짐

### PACELC 이론

- CAP 이론을 보완하기 위해 네트워크 장애 상황과 정상 상황으로 나누어서 설명
- P(네트워크 파티션)상황에서 A(가용성)과 C(일관성)의 상충 관계와 E(else, 정상)상황에서 L(지연시간)과 C(일관성)의 상충 관계를 성명

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4bb7262b-2075-4947-a159-15d4dd0663dc/Untitled.png)

### 저장 방식에 따른 NoSQL 분류

1. Key-Value Model
    - 단순한 저장 구조, 복잡한 조회 연상을 지원하지 않는다
    - 고속 읽기와 쓰기에 최적화된 경우가 많다
2. Document Model
    - 키에 하나의 구조화된 문서를 저장하고 조회
    - 저장된 문서를 컬렉션으로 관리하며 문서 저장과 동시에 문서 ID에 대한 인덱스를 생성
    - 대부분의 문서 모델은 B 트리 인덱스를 사용하여 2차 인덱스를 생성
3. Column Model
    - 하나의 키에 여러 개의 컬럼 이름과 컬럼 값의 쌍으로 이루어진 데이터를 저장하고 조회. 모든 컬럼은 항상 타임 스탬프 값과 함께 저장
    - 구글의 빅테이블이 대표적인 예
    - Row key, Column Key, Column Family, 로우들의 집합은 Key Space
    - 쓰기에 특화. 데이터를 먼저 커밋로그와 메모리에 저장한 후 응답하기 때문에 빠른 응답속도
    - 쓰기 연상이 많은 서비스, 빠른 시간 안에 대량의 데이터를 입력하고 조회하는 서비스를 구현할 때 가장 좋은 성능 - 채팅 내용 저장, 실시간 분석을 위한 데이터 저장소

### NoSQL 데이터 모델링 패턴

1. Denormalization(비정규화)
    - 같은 데이터를 중복해서 저장
    - 테이블간의 Join을 없앨 수 있다
    - 장점
        - 쿼리 당 IO횟수 감소
        - 쿼리 데이터 사이즈 감소
        - 쿼리 수행 복잡도 감소
    - 단점
        - 전체 데이터 사이즈 증가
        - 데이터 일관성 문제 발생 가능
2. Aggregation
    - Scheme-less / Soft Scheme라는 특성을 이용하여 1:N같은 복잡한 entity들의 관계를 손쉽게 하나의 테이블로 바꿀 수 있음
    - Join 연산을 줄임 → 수행시간 단축, 저렴한 비용의 대용량 데이터 지원 가능
3. Application Side Join
    - 어쩔 수 없이 Join 기능을 구현해야 하는 경우, 애플리케이션에서 Join로직을 처리
    - Join이 필요한 테이블의 수 만큼 NoSQL로의 request/response IO가 발생하지만, 비정규화에 비해서 스토리지 사용량은 감소
